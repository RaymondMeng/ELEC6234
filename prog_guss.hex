//n=8bits Isize=16+n=24bits
//format: 6b opcode, 5b %d, 5b %s, ***8b immediate or address***
// 对于ADDI,SUBI来说确实是立即数，但对于ADD，SUB，以及条件跳转指令来说，确实是地址
//
// HEX /////////// BINARY  ///////////////////// ASSEMBLER /////////
000000    // 24'b0000_0000_0000_0000_0000_0000   NOP
//输出初始化
2BA000     //24'b0010_1011_1010_0000_0000_0000   ADDI %29, %0, 0; reg29 = 0; reg29为输出寄存器

000000    // 24'b0000_0000_0000_0000_0000_0000   MAIN

28C001    // 24'b0010_1000_1100_0000_0000_0001   ADDI %6, %0, #1; reg6 = 1  临时寄存器赋值为1
6FC600    // 24'b0110_1111_1100_0110_0000_0000   BNE %30, %6, #0; 条件分支跳转while(~sw8); PC = (%d!=%s? PC+ imm : PC+1)
293F00    // 24'b0010_1001_0011_1111_0000_0000   ADDI %9, %31, #0;  load sw7~0 in register 9 (i) 

282011    // 24'b0010_1000_0010_0000_0001_0001   ADDI %1, %0, #17;  load 17 in register 1 (K0)
28401D    // 24'b0010_1000_0100_0000_0001_1101   ADDI %2, %0, #29;  load 29 in register 2 (K1)
286023    // 24'b0010_1000_0110_0000_0010_0011   ADDI %3, %0, #35;  load 35 in register 3 (K2)
28801C    // 24'b0010_1000_1000_0000_0001_1101   ADDI %4, %0, #29;  load 29 in register 4 (K3)
28A011    // 24'b0010_1000_1010_0000_0001_0001   ADDI %5, %0, #17;  load 17 in register 5 (K4)

28C000    //24'b0010_1000_1100_0000_0000_0000   ADDI %6, %0, #0; reg6 = 0 复位

//计算S[i]
2D4902     //24'b0010_1101_0100_1001_0000_0010  SUBI %10, %9, #2; reg10 = reg9(i) - 2;
A0EA00     //24'b1010_0000_1110_1010_0000_0000  LOAD %7, %10; reg7 = rom[i-2];
1CE100     //24'b0001_1100_1110_0001_0000_0000  MULTI %7, %1; reg7 = reg7 * reg1;
08C700     //24'b0000_1000_1100_0111_0000_0000  ADD %6, %7; reg6 = reg6 + reg7;

2D4901     //24'b0010_1101_0100_1001_0000_0001  SUBI %10, %9, #1; reg10 = reg9(i) - 1;
A0EA00     //24'b1010_0000_1110_1010_0000_0000  LOAD %7, %10; reg7 = rom[i-1];
1CE200     //24'b0001_1100_1110_0010_0000_0000  MULTI %7, %2; reg7 = reg7 * reg2;
08C700     //24'b0000_1000_1100_0111_0000_0000  ADD %6, %7; reg6 = reg6 + reg7;

A0E900     //24'b1010_0000_1110_1001_0000_0000  LOAD %7, %9; reg7 = rom[i];
1CE300     //24'b0001_1100_1110_0011_0000_0000  MULTI %7, %3; reg7 = reg7 * reg3;
08C700     //24'b0000_1000_1100_0111_0000_0000  ADD %6, %7; reg6 = reg6 + reg7;

294901     //24'b0010_1001_0100_1001_0000_0001  ADDI %10, %9, #1; reg10 = reg9(i) + 1;
A0EA00     //24'b1010_0000_1110_1010_0000_0000  LOAD %7, %10; reg7 = rom[i+1];
1CE400     //24'b0001_1100_1110_0100_0000_0000  MULTI %7, %4; reg7 = reg7 * reg4;
08C700     //24'b0000_1000_1100_0111_0000_0000  ADD %6, %7; reg6 = reg6 + reg7;

294902     //24'b0010_1001_0100_1001_0000_0010  ADDI %10, %9, #2; reg10 = reg9(i) + 2;
A0EA00     //24'b1010_0000_1110_1010_0000_0000  LOAD %7, %10; reg7 = rom[i+2];
1CE500     //24'b0001_1100_1110_0101_0000_0000  MULTI %7, %5; reg7 = reg7 * reg5;
08C700     //24'b0000_1000_1100_0111_0000_0000  ADD %6, %7; reg6 = reg6 + reg7;

2BA600     //24'b0010_1011_1010_0110_0000_0000  ADDI %29, %6, 0; reg29 = reg6;  led_o = reg6  输出缓存一拍  reg29为输出寄存器
C00002     //24'b1100_0000_0000_0000_0000_0010  JUMP MAIN



